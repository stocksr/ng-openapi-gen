import { InterfaceDeclaration, TypeAliasDeclaration, TypescriptParser } from 'typescript-parser';
import { NgOpenApiGen } from '../lib/ng-openapi-gen';
import options from './inherit.config.json';
import selfRef from './inherit.json';

const gen = new NgOpenApiGen(selfRef, options);
gen.generate();

describe('Generation of derived classes with discriminator using inherit.json (as is generated by Swashbuckle)', () => {
  it('Base Model - does not have the discriminator property', (done) => {
    const tazk = gen.models.get('FooBaseType');
    const ts = gen.templates.apply('model', tazk);
    const parser = new TypescriptParser();
    parser.parseSource(ts).then((ast) => {
      expect(ast.declarations.length).toBe(1);
      expect(ast.declarations[0]).toEqual(jasmine.any(InterfaceDeclaration));
      const decl = ast.declarations[0] as InterfaceDeclaration;
      expect(decl.name).toBe('FooBaseType');
      
      const text = ts.substring(decl.start || 0, decl.end || ts.length);
      expect(text).not.toContain('$type');
      done();
    });
  });

  it('DriviedClassName1 model - has the discriminator property hardecoded to the corrrect value  ', (done) => {
    const tazk = gen.models.get('DriviedClassName1');
    const ts = gen.templates.apply('model', tazk);
    const parser = new TypescriptParser();
    parser.parseSource(ts).then((ast) => {
      expect(ast.declarations.length).toBe(1);
      expect(ast.declarations[0]).toEqual(jasmine.any(TypeAliasDeclaration));
      const decl = ast.declarations[0] as TypeAliasDeclaration;
      expect(decl.name).toBe('DriviedClassName1');
      const text = ts.substring(decl.start || 0, decl.end || ts.length);
      expect(text).toContain("'$type': 'DriviedClassName1, Assembly';");
      done();
    });
  });
});
